Phase 1: Initialization (The Setup)

Before any loop starts, the World constructor prepares the memory stages.

    ChunkPool Init (world.h): Allocates thousands of lightweight ChunkNode objects (metadata only). They are empty and waiting.

    VoxelPool Init (world.h): Allocates a smaller pool (e.g., 200) of heavy Chunk objects (35KB voxel arrays). These are the "working memory."

    GpuMemoryManager (gpu_memory.h):

        Call: glMapNamedBufferRange(..., GL_MAP_PERSISTENT_BIT | GL_MAP_COHERENT_BIT)

        Result: It reserves a massive block of VRAM (e.g., 1GB) and gets a void* pointer to it.

        Why: This allows the CPU to write directly to VRAM without asking the driver for permission every frame.

    GpuCuller Init (gpu_culler.h): Creates SSBOs (Shader Storage Buffer Objects) to hold the list of chunk positions/bounds on the GPU.





Phase 2: The Logic Loop (CPU Side)

Everything starts in World::Update.
Step 1: Determining What Exists (Task_CalculateLODs)

    Trigger: The camera moves significantly.

    Input: Camera Position.

    Process:

        It loops through concentric rings (LOD levels) around the player.

        It calculates which coordinates (x, y, z) should exist.

        It checks m_chunks map to see if they do exist.

    Output: LODUpdateResult struct containing a list of ChunkRequest (coordinates that need to be created) and chunksToUnload.

Step 2: Allocation (UpdateLODs_Async)

    Process: Reads the LODUpdateResult.

    Action: Calls m_chunkPool.Acquire() for every new chunk.

    Result: You now have a ChunkNode with coordinates, but no voxel memory (chunk* == nullptr) and no mesh.

    Next: Enqueues Task_Generate.

Step 3: Generation (Task_Generate -> FillChunk)

    Thread: Background Worker.

    Input: ChunkNode* (Lightweight).

    Process (Optimization A & B):

        Calculates noise heights for the chunk area (cheap CPU math).

        Decision:

            Empty/Solid: Sets node->isUniform = true. Returns.

            Complex: Calls m_voxelPool.Acquire(). Now node->chunk points to a heavy 35KB array. Fills it with block IDs (Air, Dirt, Stone).

    Output: node->minAABB / maxAABB are set. node->chunk is filled (or null). Pushed to m_generatedQueue.

Step 4: Dispatching (ProcessQueues - Part 1)

    Thread: Main Thread.

    Process: Checks m_generatedQueue.

    Logic:

        If node->isUniform: Mark state as ACTIVE. Done. (If it had memory, release it).

        If not uniform: Enqueue Task_Mesh.

Step 5: Meshing (Task_Mesh -> MeshChunk)

    Thread: Background Worker.

    Input: ChunkNode* (accessing *chunk).

    Process (Greedy Meshing):

        Scans the voxel grid (mesher.h).

        Uses SIMD (AVX2) to process 32 blocks at once.

        Combines adjacent faces into large rectangles (quads) to reduce triangle count.

        Compresses data into PackedVertex (4 bytes per vertex: x, y, z, normal, texture packed into bits).

    Output: node->cachedMesh (std::vector<PackedVertex>) in System RAM. Pushed to m_meshedQueue.

Step 6: Upload (ProcessQueues - Part 2)

    Thread: Main Thread.

    Process:

        VRAM Allocation: Calls m_gpuMemory->Allocate(size). Returns an integer offset (e.g., byte 1,048,576).

        Copy: Calls memcpy to move data from node->cachedMesh to m_gpuMemory's persistent pointer. The data is now on the GPU.

        Metadata: Calls m_culler->AddOrUpdateChunk. This sends the offset, vertexCount, and AABB to the GpuCuller's internal SSBO.

        Cleanup (Critical):

            node->cachedMesh.clear() (Free Mesh RAM).

            m_voxelPool.Release(node->chunk) (Free Voxel RAM).

    State: The chunk is now just a metadata node on CPU and a blob of data on GPU.




Phase 3: The Render Loop (GPU Side)

This happens every frame in World::Draw.
Step 7: Occlusion Preparation (GenerateHiZ)

    Input: The depth buffer from the previous frame.

    Process: A Compute Shader downsamples the depth buffer into a "Pyramid" (Mipmaps).

    Why: Allows the culler to quickly check if a large chunk is hidden behind a large hill.

Step 8: Culling (m_culler->Cull)

    Input:

        Global Chunk Buffer (List of all AABBs and Offsets).

        Camera Matrices (Frustum).

        Hi-Z Depth Texture.

    Process (Compute Shader):

        Frustum Cull: Is the box within the camera's view cone?

        Occlusion Cull: Is the box behind the depth values in the Hi-Z buffer?

    Output:

        m_visibleChunkBuffer: A compacted list of IDs for visible chunks.

        m_indirectBuffer: A buffer of DrawElementsIndirectCommand structs (Count, InstanceCount, FirstIndex, BaseVertex, BaseInstance).

Step 9: Rasterization (m_culler->DrawIndirect)

    Call: glMultiDrawElementsIndirect(...) (or similar).

    Input: The m_indirectBuffer generated by Step 8.

    Vertex Shader:

        Does not take standard attributes (layout(location=0) in vec3 pos).

        Instead, it uses gl_VertexID and gl_DrawID.

        It reads the specific PackedVertex from the massive GpuMemoryManager SSBO using (GlobalOffset + VertexID).

        Unpacks the compressed bits (position 0..63, normal 0..7) back into floats.

        Transforms by View/Projection matrix.

    Fragment Shader: Apply textures/lighting.

    Result: Pixels on screen.